# Lesson 2 - Intro to Testing in Rails

## Recap & Agenda

In our last class, we covered Rspec basics by building a ruby application and writing tests. 

Tonight we will cover: 

- Testing Rails Applications
	- setup/config
	- Unit tests
	- Model Specs
		- Validations
		- Associations
		- Instance Methods 
- Useful Gems including:
	- Guard
	- Factory Girl
	- Ffaker  
- Using Factories 
- Some New Rspec syntax 


*We will be working with [this](https://github.com/NextLevelRails-winter-2016/todo_with_rspec) repo* 

## Application Setup

### Setup

Rails ships with MiniTest as the default test suite. As stated before, MiniTest is an excellent testing framework. We, however are going to use Rspec. 

The easiest way to do this get started with Rails/Rspec is to use the `-T` flag in your `rails new` new command

```shell
$ rails new TodoApp -T
```

This will skip the default Rails behavior of setting up a spec directory 

Next, we'll be go ahead and add several Gems to our Gemile. 

Add the following Gems to `group :development, :test` 

```ruby
  gem 'rspec-rails'
  gem 'capybara'
  gem 'factory_girl_rails'
  gem 'rails-controller-testing'
```

- [rspec-rails](https://github.com/rspec/rspec-rails) is an adaptation of rspec specifically built for rails 
- [capybara](https://github.com/jnicklas/capybara) is used for testing your views
- [factory-girl-rails](https://github.com/thoughtbot/factory_girl_rails) is a rails version of factory-girl. A library for setting up Ruby objects as test data
- [rails-controller-testing](https://github.com/rails/rails-controller-testing) contains helpful methods for testing controllers 

### Config 

After updating our gemfile we'll run `$ bundle install` and begin setting our project up for Rspec. 

To initialize Rspec run: 

```shell
$ rails g rspec:install
```

Which should lead to the following output: 

```shell
create  .rspec
create  spec
create  spec/spec_helper.rb
create  spec/rails_helper.rb
```

The following 4 items were generated by this command:

- `.rspec` file - used for configuring rspec
- `spec` directory - for holding all of our tests
- `spec/spec_helper.rb` - a lightweight file for handling non-rails specs
- `spec/rails_helper.rb` - a helper file for code dependent on rails

#### `.rspec`

The `.rspec` file passes additional arguments to our tests. If you open the file, you will notice the following 2 items 

- `--color`
- `--require spec_helper`

We are going to add an optional third argument of `--format documentation` which makes our specs more readable

#### `spec_helper` vs `rails_helper`

It would be worth taking a few minutes to review the comments generated in these files. However, I will leave that for you to do as homework. 

In a nutshell, the major difference is that `spec_helper` is specifically used for your core Rspec configuration and avoids loading Rails when not necessary. While `rails_helper` is used for testing your normal rails code. You'll notice that `require 'rails_helper'` will be added to the vast majority of our specs moving forward. 

To learn more about this, you can read [spec_helpers](https://relishapp.com/rspec/rspec-rails/docs/upgrade#default-helper-files) 

### Optional setup

While the next steps are optional, I find it best to go ahead and implement them if possible. 

#### Guard

in your Gemfile add the following gems to your `:development` group, and then `bundle install`

```ruby
  gem 'guard'
  gem 'guard-rspec', require: false
```

[Guard](https://github.com/guard/guard) is a wonderful development gem that handles task automation, probably deserving a class of all of its own.

For our purposes, we will be using Guard to run our specs when a related file is saved. 

To use Guard, we will start by generating a **Guardfile**

```shell
$ bundle exec guard init
```

Our Guardfile contains config options for guard. Because we added the `guard-rspec` gem, our Guardfile contains specific instructions for rspec. 

We can run guard by typing:

```shell
$ bundle exec guard
```

Guard is now watching for any new changes to our specs, models, controllers, etc. and will run anytime we make changes and save them. 

*note: to run your entire test suite, simply press `enter`*

While this is not necessary, I find it to be a huge time-saver. 

- - - -

## Testing our Models

When testing, Model tests are usually a great place to start. This type of test is also known as a **Unit Test**

We'll start by generating a Task model with name and priority attributes

```shell
$ rails g model Task name priority:integer
```

If you look at the generated files, you'll notice that along with our migration and model files, Rails also created two files in our specs directory. 

Let's navigate to `spec/models/task_spec.rb`

Currently, we have one pending test reminding us to add some tests. Let's do that now. 

Unit tests usually meet the following criteria

- Describe the behavior of a class 
- Are explicit in description
- Independent of other tests 
- Each spec tests 1 item

Our model specs should test for the following types of things: 

### Validations

Let's start by writing validation tests. 

```ruby
require 'rails_helper'

RSpec.describe Task, type: :model do

  it 'is invalid without a name' 

  it 'is invalid without a priority'
  
end
```

By running our tests, we'll see that all are pending.

<!--Now, let's think about the code that we'll need for this first test to pass. 

```ruby
  it 'is valid with required attributes' do
    task = Task.new(name: 'Learn Rspec', priority: 1)
    expect(task).to be_valid
  end
```
-->

Let's think about the code required for the first test to run

```ruby
it 'is invalid without a name' do 
  task = Task.new(name: nil, priority: 1)
	
  expect(task).not_to be_valid
end
```

What is this test saying? 

- instantiate a new task, without a name
- that task should not be allowed into the database

- - - - 

##### Alternatives

A couple of other ways to write this test are: 

```ruby
it 'is invalid without a name' do
  task = Task.new(name: nil, priority: 1)
    
  expect(task.save).to eq(false)
end
```

or 

```ruby
it 'is invalid without a name' do
  task = Task.new(name: nil, priority: 1)
  task.valid?
    
  expect(task.errors[:name]).to include("can't be blank")
end
```

Write the test that makes the most sense to you. 

- - - - 

Now, when we run our test, we'll get a failure. This is due to the fact that we have not included actual validations in our model. 

Navigate to `app/models/task.rb` and add: 

```ruby 
validates :name, presence: true
```

Run your test again, and it should be passing!  

*note: you may be tempted to go ahead and write your second validation. refrain from that for now, so you get in the habit of writing tests, watching them fail, making them pass*


## Challenge 1 

- Clone the [todo_with_rspec](https://github.com/NextLevelRails-winter-2016/todo_with_rspec) repo from our Class GitHub org
- Follow the instructions in the README
- Complete: 
	- Setup
	- Step 1


- - - -   

Your model spec is also where you would have any class/instance methods.<br>
For example, let's say we have a User model with `firstname` and `lastname` attributes. We could write a test for a `full_name` method. 

Our spec would look something like this: 

```ruby
it 'shows first and last name for full_name method' do
	user = User.new(firstname: 'shane', lastname: 'barringer'
	
	expect(user.full_name).to eq('shane barringer')
end
```

the code in our user model would then look like: 

```ruby
def full_name
	return "#{self.firstname} #{self.lastname}"
end
```

- - - - 

Now that we have passing tests, it's a good time to do some refactoring. Often, you can refactor your code and your tests. In our example, only the tests can be refactored. 

## Factories

Until now, we've been declaring objects in each of our tests, and while this works, it can become verbose quickly. You can imagine that as tests become more complex, our instantiated objects will increase in complexity as well. 

There are several ways to address this including, the `before` hook and fixtures. We, however, are going to use Factories. 

Factories provide a simple and elegant way to create test data. This is accomplished by using the [Factory Girl](https://github.com/thoughtbot/factory_girl) gem. 

### Building Factories

To start, navigate to `spec/factories/tasks.rb`

You may already have a pre-defined factory. either way, let's create one: 

```ruby
FactoryGirl.define do
  factory :homework, class: Task do
    name "complete homework"
    priority 1
  end
end
```

Breaking it down: 

- We wrap everything in the `FactoryGirl.define` block
- Create a factory with the name `:homework`
- Specify the factory belongs to the Task class
- Inside the *homework factory* we add: 
	- a **name** of completed homework
	- a **priority** of 1
	- *name and priority are both methods and whatever data we pass in is considered an argument*

We can create a second Factory in the same fashion: 

```ruby
  factory :email, class: Task do
    name "reply to Zack's email"
    priority 2
  end
```

While we're here, let's create an invalid_task factory

```ruby
  factory :invalid_task, class: Task do
    name nil    
    priority nil
  end
```

### Testing Factories

Now that we have some factories, let's implement them in our tests. 

Navigate back to `spec/models/task_spec`

First, let's write a test for loading factory data

```ruby 
it 'has a valid factory' do 
	expect(FactoryGirl.build(:homework)).to be_valid
end
```

This should pass as expected, however, let's change it (temporarily) to `:invalid_task` to insure that we won't get a false positive. 

```ruby
expect(FactoryGirl.build(:invalid_task)).to be_valid
``` 

As expected, our test fails due to validations we've previously put in place. Now we can change `:invalid_task` to `:homework` and move on. 

### FactoryGirl config

Before we go any further, do the following: 

navigate to `spec/rails_helper.rb` and add the following line to your `Rspec.configure` block

```ruby
config.include FactoryGirl::Syntax::Methods
```

This handly little line of code allows us to omit `FactoryGirl.WHATEVER_METHOD` from our tests. Meaning we can now simply call: `build(:homework)` or `create(:email)` to instatiate objects from our Factories. 

While you're in the `rails_helper` go ahead and comment out the line: 

`config.fixture_path = "#{::Rails.root}/spec/fixtures"` as we have chosen to use factories instead of fixtures. 


Now, let's use our Factories in all of our specs

```ruby
require 'rails_helper'

RSpec.describe Task, type: :model do
  it 'has a valid factory' do
  	expect(build(:homework)).to be_valid
  end

  it 'is valid with required attributes' do
    task = create(:email)
    expect(task).to be_valid
  end

  it 'is invalid without a name' do
    task = build(:homework, name: nil)
    expect(task).not_to be_valid
  end

  it 'is invalid without a priority' do
    task = build(:email, priority: nil)
    expect(task).not_to be_valid
  end
end
```

You'll notice here, that for our last 2 specs we've added some `nil` attributes. This will override the data passed in from our factory generated object. 

	
FactoryGirl is deserving of a full class, and we will continue to explore it throughout the course. However, to learn more check out the [Getting Started Docs](https://github.com/thoughtbot/factory_girl/blob/master/GETTING_STARTED.md)

## Testing Associations

### Add a user model

This is a great point to talk about associations both in our tests and our factories

We'll start by adding a user model 

```shell
$ rails g model User firstname lastname email && rake db:migrate
```

Next we'll create a migration for our Tasks model to add the attributes `user_id` and `due_date`

```shell
$ rails g migration AddUserIdAndDueDateToTasks due_date:datetime user:references && rake db:migrate
```
### Write our tests 

Let's start by sketching out the basic tests we know we'll need. 

In `spec/models/tasks_spec.rb` add: 

```ruby
  it 'is invalid without Due Date' 

  it 'belongs to User'
```

And in `spec/users_spec.rb` add: 

```ruby
require 'rails_helper'

RSpec.describe User, type: :model do

  it 'is invalid without firstname'

  it 'is invalid without lastname'

  it 'is invalid without email'
  
  it 'is invalid without unique email'

  it 'has many tasks'
end
```

We can run our entire test suite by pressing `enter` (with guard running) or giving the command: `$ rspec .` (without guard running) 

### Supplying Fake data to our Factories 

The next step is to setup our factories to generate data for our tests. This is a great time to introduce you to an excellent gem that goes by the name of Ffaker. 

[Ffaker](https://github.com/ffaker/ffaker) generates fake data for almost any data-type/attribute you could imagine, and can make fun things come to light

To start, let's add Ffaker to our Gemfile 

```ruby
group :development, :test do
   # ... other gems 
   
   gem 'ffaker'
end
```

*note: don't forget to `bundle install`*

We can use Ffaker directly in our specs of factories. Let's see what it looks like in our User Factory. Navigate to `spec/factories/users.rb` and add:

```ruby
FactoryGirl.define do
  factory :user do
    firstname { FFaker::Name.first_name }
    lastname { FFaker::Name.last_name }
    email { FFaker::Internet.email }
  end
end
```

Let's break down the new syntax 

First, we are using `{}` for each of our attribute assignments. This is because our factory methods can take a block, to execute code. 

Inside the block, we are using Ffaker to generate our data.<br> 
Using Ffaker is fairly straight forward and detailed clearly in [the Documentation](https://github.com/ffaker/ffaker/blob/master/REFERENCE.md)

For our purpose we are using the `Name` and `Internet` modules. 

According to FFaker's documentation. You reference the module and then look for specific methods to generate the appropriate data. 

At this point, we can go ahead and write start implementing tests and code. Let's start working through it by testing the validity of our factory

```ruby
  it 'has a valid factory' do
    expect(build(:user)).to be_valid
  end
```

This spec should pass, so let's move on. 


### let

It's time to introduce you to another Rspec feature: `let()`

here's what it looks like: 

```ruby
RSpec.describe User, type: :model do

  let(:user) { build(:user) }

  # specs below
end  
```

`let()` is used by many Rspec developers as a substitue for `before :each`. And`let` offers a couple of benefits 
 
- it caches the value, avoiding the use of an instance variable 
- it is lazily evaluated, meaning that it is not assigned until called on by a spec

For more on the benefits of using `let` check out this [StackOverflow Post](http://stackoverflow.com/questions/5359558/when-to-use-rspec-let/5359979#5359979)

Now, we can utilize the user variable created by `let` in our specs 

```ruby
  let(:user) { build(:user) }

  it 'has a valid factory' do
    expect(user).to be_valid
  end

  it 'is invalid without firstname' do
    user.firstname = nil
    expect(user).not_to be_valid
  end
```

Here you can see that the user has been instantiated and we have re-assigned the `firstname` attribute to `nil` in order to test our validation

As for `let` there can also be some drawbacks, such as *mystery guests* causing your tests become obsecure and unreadable.

*Remember, when it comes to your specs, DRYer is not always better.*

There are many opinions on how much and when to use `let` I'll leave it up to you.



Let's go ahead and implement our other validation tests

```ruby
  it 'is invalid without lastname' do
    user.lastname = nil
    expect(user).not_to be_valid
  end

  it 'is invalid without email' do
    user.email = nil
    expect(user).not_to be_valid
  end
```

And the passing code: 

```ruby
class User < ApplicationRecord
  validates :firstname, presence: true
  validates :lastname, presence: true
  validates :email, presence: true 
end
```

Now for our uniqueness validation

```ruby
it 'is invalid without unique email' do
    user.save
    other_user = build(:user, email: user.email)
    other_user.valid?
    
    expect(other_user.errors[:email]).to include('has already been taken')
end
```

There are several ways we can write a validation test, the above is a fairly clear example

- save the user built with `let`
- build another user object and assign the email from our first user
- check to see if our `other_user` object is valid
- expect an error message stating 'has already been taken'

The passing code will be: 

```ruby
  validates :email, presence: true, uniqueness: true
```



#### 


### Associations

Now we can work on associations. The best place to start would be our Factories. Thankfully, FactoryGirl makes associations pretty straight-forward with the following syntax: `association :factory_name`

navigate to `specs/factories/tasks.rb`

```ruby
  factory :homework, class: Task do
    association :user
    name "complete homework"
    priority 1
  end

  factory :email, class: Task do
    association :user
    name "reply to Zack's email"
    priority 2
  end
```

This implies that when our tasks are created, a user object (from the user factory) will be associated with the Task object. In other words, The user's id, will be assigned to the `user_id` attribute. 


#### FactoryGirl Callbacks 
With this being accomplished, let's navigate to our User Factory and add a callback

```ruby
FactoryGirl.define do
  factory :user do
    firstname { FFaker::Name.first_name }
    lastname { FFaker::Name.last_name }
    email { FFaker::Internet.email }

    after(:build) do |user|
      [:email, :homework].each do |task|
        user.tasks << FactoryGirl.build(:homework,
          name: task,
          user: user
        )
      end
    end
  end
end
```

Before we discuss what happens within the callback. Let me explain FactoryGirl's callbacks.

FactoryGirl provides you with callbacks that can be used after your factory has been created. In our case, we want to associate several tasks with our User to test our associations...

- After we build the user
- create an array of tasks (from the tasks factory)
- Iterate over the array of tasks and assign those tasks to the user 
	- Build a task 
	- assign a name (from the array)
	- assign/associate the user object

For our user spec, we can write: 

```ruby
it 'has two tasks' do
  expect(user.tasks.length).to eq(2)
end
```

The passing code will be written in our models

In our User model add:

```ruby
has_many :tasks
```

In our Task model add: 

```ruby
belongs_to :user
```

Last, let's add a test to our tasks spec to test our associations

```ruby
it 'belongs to User' do
   expect(Task.reflect_on_association(:user).macro).to eq(:belongs_to)
end
```

This test says to simply look at all of Task's assocations and make sure that it `belongs_to` User. 

While we're in our Tasks spec, we can also write our test for Due Date validation

```ruby
it 'is invalid without Due Date' do
  task = build(:homework, due_date: nil)
  expect(task).not_to be_valid
end
```

Our Tasks factory will look something like this: 

```ruby
 factory :homework, class: Task do
    association :user
    name "complete homework"
    due_date { DateTime.now }
    priority 1
  end

  factory :email, class: Task do
    association :user
    name "reply to Zack's email"
    due_date { DateTime.now + 2.days }
    priority 2
  end
```



### Due Today

Finally, for fun, let's add a method to return only the tasks that are due today. 


```ruby
 it 'returns tasks due today' do
   task = user.tasks.first
   task.update(due_date: DateTime.now)
   expect(user.due_today.length).to eq(1)
 end
```

Here, we are going to create a task, and update the due_date. Afterwards we will test to insure that an array is returned with 1 item.

The passing code will be written in our User model

```ruby
  def due_today
    self.tasks.select{ |t| t.due_date.to_date == DateTime.now.to_date }
  end
```

## Homework

###**Due 11/21/16**

- Read and Follow along with [How to Test Rails Models](https://semaphoreci.com/community/tutorials/how-to-test-rails-models-with-rspec)
	- Once finished push your copy of code with the following naming convention: `Auction_YOUR_INITIALS_HERE`
	- Make a comment in the read me giving credit to the author or website
- Read [Factory Girl 101](https://code.tutsplus.com/articles/factory-girl-101--cms-25087) 
	- Write a sentence about your 3 biggest takeaways from the article 
	- Turn them in through DM on slack
- Write the User and Post models *and specs* for a Blog application
	- Configure your application to use Rspec  
	-Your user model will have the following 2 attributes: 
		- username
		- email
	- The Post model will have the following attributes 
		- title
		- article 
	- Write the following tests: 
		- Validation of all fields 
		- Assocations tests
	- Use the Todo App for inspiration
	- Write your tests first!

